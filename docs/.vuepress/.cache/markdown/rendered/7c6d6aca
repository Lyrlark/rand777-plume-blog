{"content":"<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">问题</p>\n<p>vue2 与 vue3 有哪些区别？</p>\n</div>\n<hr>\n<h3 id=\"_1-响应式系统\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-响应式系统\"><span>1. 响应式系统</span></a></h3>\n<ul>\n<li><strong>Vue 2</strong>：基于 <code v-pre>Object.defineProperty()</code> 实现，通过劫持对象属性的 <code v-pre>getter</code> 和 <code v-pre>setter</code> 追踪变化。存在局限性，无法检测对象属性的添加或删除，对数组部分操作（如通过索引修改元素、修改数组长度）不能触发响应式更新。</li>\n<li><strong>Vue 3</strong>：采用 <code v-pre>Proxy</code> 对象实现，能拦截对象多种操作，可全面追踪数据变化，解决了 Vue 2 响应式系统的局限，对对象属性的添加、删除及数组操作都能很好地进行响应式处理。</li>\n</ul>\n<h3 id=\"_2-组合式-api-与选项式-api\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-组合式-api-与选项式-api\"><span>2. 组合式 API 与选项式 API</span></a></h3>\n<ul>\n<li><strong>Vue 2</strong>：使用选项式 API，通过 <code v-pre>data</code>、<code v-pre>methods</code>、<code v-pre>computed</code>、<code v-pre>watch</code> 等选项组织代码。组件逻辑复杂时，同一功能代码分散，降低了代码可读性和可维护性。</li>\n<li><strong>Vue 3</strong>：引入组合式 API，有 <code v-pre>setup</code> 函数及一系列组合式函数，允许按逻辑功能组织代码，将相关代码放一起，提高了代码复用性和可维护性。</li>\n</ul>\n<h3 id=\"_3-生命周期钩子\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-生命周期钩子\"><span>3. 生命周期钩子</span></a></h3>\n<ul>\n<li><strong>Vue 2</strong>：有 <code v-pre>beforeCreate</code>、<code v-pre>created</code>、<code v-pre>beforeMount</code>、<code v-pre>mounted</code>、<code v-pre>beforeUpdate</code>、<code v-pre>updated</code>、<code v-pre>beforeDestroy</code>、<code v-pre>destroyed</code> 等钩子函数。</li>\n<li><strong>Vue 3</strong>：部分钩子名称改变，如 <code v-pre>beforeDestroy</code> 变为 <code v-pre>onBeforeUnmount</code>，<code v-pre>destroyed</code> 变为 <code v-pre>onUnmounted</code>；还可在 <code v-pre>setup</code> 中使用组合式 API 形式的生命周期钩子。</li>\n</ul>\n<h3 id=\"_4-性能优化\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-性能优化\"><span>4. 性能优化</span></a></h3>\n<ul>\n<li><strong>Vue 2</strong>：虚拟 DOM 采用传统的 Diff 算法，在处理大规模数据更新时性能会受到一定影响。</li>\n<li><strong>Vue 3</strong>：采用了静态提升、Patch Flag 等优化技术。静态提升可减少重复创建静态节点，Patch Flag 能精准标记动态节点，提高 Diff 算法效率，提升渲染性能。</li>\n</ul>\n<h3 id=\"_5-破坏性变更\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-破坏性变更\"><span>5. 破坏性变更</span></a></h3>\n<ul>\n<li><code v-pre>v-model</code> 语法变更（默认使用 <code v-pre>modelValue</code> 替代 <code v-pre>value</code>）。</li>\n<li>事件总线 (<span v-pre class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>o</mi><mi>n</mi><mi mathvariant=\"normal\">/</mi></mrow><annotation encoding=\"application/x-tex\">on/</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span></span></span></span>off) 被移除，推荐使用第三方库（如 <code v-pre>mitt</code>）。</li>\n</ul>\n<h3 id=\"_6-类型支持\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_6-类型支持\"><span>6. 类型支持</span></a></h3>\n<ul>\n<li><strong>Vue 2</strong>：对 TypeScript 的支持相对较弱，使用时需要额外的配置和声明文件。</li>\n<li><strong>Vue 3</strong>：从设计上就对 TypeScript 有更好的支持，组合式 API 能更自然地与 TypeScript 集成，代码类型更清晰。</li>\n</ul>\n","env":{"base":"/","filePath":"G:/200-Project/hoey-blog-plume/docs/notes/interview/4.Vue/Vue2与Vue3的区别.md","filePathRelative":"notes/interview/4.Vue/Vue2与Vue3的区别.md","frontmatter":{"title":"Vue2与Vue3的区别","createTime":"2025/02/05 13:21:37","permalink":"/interview/lrdm06i5/"},"sfcBlocks":{"template":{"type":"template","content":"<template><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">问题</p>\n<p>vue2 与 vue3 有哪些区别？</p>\n</div>\n<hr>\n<h3 id=\"_1-响应式系统\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-响应式系统\"><span>1. 响应式系统</span></a></h3>\n<ul>\n<li><strong>Vue 2</strong>：基于 <code v-pre>Object.defineProperty()</code> 实现，通过劫持对象属性的 <code v-pre>getter</code> 和 <code v-pre>setter</code> 追踪变化。存在局限性，无法检测对象属性的添加或删除，对数组部分操作（如通过索引修改元素、修改数组长度）不能触发响应式更新。</li>\n<li><strong>Vue 3</strong>：采用 <code v-pre>Proxy</code> 对象实现，能拦截对象多种操作，可全面追踪数据变化，解决了 Vue 2 响应式系统的局限，对对象属性的添加、删除及数组操作都能很好地进行响应式处理。</li>\n</ul>\n<h3 id=\"_2-组合式-api-与选项式-api\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-组合式-api-与选项式-api\"><span>2. 组合式 API 与选项式 API</span></a></h3>\n<ul>\n<li><strong>Vue 2</strong>：使用选项式 API，通过 <code v-pre>data</code>、<code v-pre>methods</code>、<code v-pre>computed</code>、<code v-pre>watch</code> 等选项组织代码。组件逻辑复杂时，同一功能代码分散，降低了代码可读性和可维护性。</li>\n<li><strong>Vue 3</strong>：引入组合式 API，有 <code v-pre>setup</code> 函数及一系列组合式函数，允许按逻辑功能组织代码，将相关代码放一起，提高了代码复用性和可维护性。</li>\n</ul>\n<h3 id=\"_3-生命周期钩子\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-生命周期钩子\"><span>3. 生命周期钩子</span></a></h3>\n<ul>\n<li><strong>Vue 2</strong>：有 <code v-pre>beforeCreate</code>、<code v-pre>created</code>、<code v-pre>beforeMount</code>、<code v-pre>mounted</code>、<code v-pre>beforeUpdate</code>、<code v-pre>updated</code>、<code v-pre>beforeDestroy</code>、<code v-pre>destroyed</code> 等钩子函数。</li>\n<li><strong>Vue 3</strong>：部分钩子名称改变，如 <code v-pre>beforeDestroy</code> 变为 <code v-pre>onBeforeUnmount</code>，<code v-pre>destroyed</code> 变为 <code v-pre>onUnmounted</code>；还可在 <code v-pre>setup</code> 中使用组合式 API 形式的生命周期钩子。</li>\n</ul>\n<h3 id=\"_4-性能优化\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-性能优化\"><span>4. 性能优化</span></a></h3>\n<ul>\n<li><strong>Vue 2</strong>：虚拟 DOM 采用传统的 Diff 算法，在处理大规模数据更新时性能会受到一定影响。</li>\n<li><strong>Vue 3</strong>：采用了静态提升、Patch Flag 等优化技术。静态提升可减少重复创建静态节点，Patch Flag 能精准标记动态节点，提高 Diff 算法效率，提升渲染性能。</li>\n</ul>\n<h3 id=\"_5-破坏性变更\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-破坏性变更\"><span>5. 破坏性变更</span></a></h3>\n<ul>\n<li><code v-pre>v-model</code> 语法变更（默认使用 <code v-pre>modelValue</code> 替代 <code v-pre>value</code>）。</li>\n<li>事件总线 (<span v-pre class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>o</mi><mi>n</mi><mi mathvariant=\"normal\">/</mi></mrow><annotation encoding=\"application/x-tex\">on/</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span></span></span></span>off) 被移除，推荐使用第三方库（如 <code v-pre>mitt</code>）。</li>\n</ul>\n<h3 id=\"_6-类型支持\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_6-类型支持\"><span>6. 类型支持</span></a></h3>\n<ul>\n<li><strong>Vue 2</strong>：对 TypeScript 的支持相对较弱，使用时需要额外的配置和声明文件。</li>\n<li><strong>Vue 3</strong>：从设计上就对 TypeScript 有更好的支持，组合式 API 能更自然地与 TypeScript 集成，代码类型更清晰。</li>\n</ul>\n</template>","contentStripped":"<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">问题</p>\n<p>vue2 与 vue3 有哪些区别？</p>\n</div>\n<hr>\n<h3 id=\"_1-响应式系统\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_1-响应式系统\"><span>1. 响应式系统</span></a></h3>\n<ul>\n<li><strong>Vue 2</strong>：基于 <code v-pre>Object.defineProperty()</code> 实现，通过劫持对象属性的 <code v-pre>getter</code> 和 <code v-pre>setter</code> 追踪变化。存在局限性，无法检测对象属性的添加或删除，对数组部分操作（如通过索引修改元素、修改数组长度）不能触发响应式更新。</li>\n<li><strong>Vue 3</strong>：采用 <code v-pre>Proxy</code> 对象实现，能拦截对象多种操作，可全面追踪数据变化，解决了 Vue 2 响应式系统的局限，对对象属性的添加、删除及数组操作都能很好地进行响应式处理。</li>\n</ul>\n<h3 id=\"_2-组合式-api-与选项式-api\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_2-组合式-api-与选项式-api\"><span>2. 组合式 API 与选项式 API</span></a></h3>\n<ul>\n<li><strong>Vue 2</strong>：使用选项式 API，通过 <code v-pre>data</code>、<code v-pre>methods</code>、<code v-pre>computed</code>、<code v-pre>watch</code> 等选项组织代码。组件逻辑复杂时，同一功能代码分散，降低了代码可读性和可维护性。</li>\n<li><strong>Vue 3</strong>：引入组合式 API，有 <code v-pre>setup</code> 函数及一系列组合式函数，允许按逻辑功能组织代码，将相关代码放一起，提高了代码复用性和可维护性。</li>\n</ul>\n<h3 id=\"_3-生命周期钩子\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_3-生命周期钩子\"><span>3. 生命周期钩子</span></a></h3>\n<ul>\n<li><strong>Vue 2</strong>：有 <code v-pre>beforeCreate</code>、<code v-pre>created</code>、<code v-pre>beforeMount</code>、<code v-pre>mounted</code>、<code v-pre>beforeUpdate</code>、<code v-pre>updated</code>、<code v-pre>beforeDestroy</code>、<code v-pre>destroyed</code> 等钩子函数。</li>\n<li><strong>Vue 3</strong>：部分钩子名称改变，如 <code v-pre>beforeDestroy</code> 变为 <code v-pre>onBeforeUnmount</code>，<code v-pre>destroyed</code> 变为 <code v-pre>onUnmounted</code>；还可在 <code v-pre>setup</code> 中使用组合式 API 形式的生命周期钩子。</li>\n</ul>\n<h3 id=\"_4-性能优化\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_4-性能优化\"><span>4. 性能优化</span></a></h3>\n<ul>\n<li><strong>Vue 2</strong>：虚拟 DOM 采用传统的 Diff 算法，在处理大规模数据更新时性能会受到一定影响。</li>\n<li><strong>Vue 3</strong>：采用了静态提升、Patch Flag 等优化技术。静态提升可减少重复创建静态节点，Patch Flag 能精准标记动态节点，提高 Diff 算法效率，提升渲染性能。</li>\n</ul>\n<h3 id=\"_5-破坏性变更\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_5-破坏性变更\"><span>5. 破坏性变更</span></a></h3>\n<ul>\n<li><code v-pre>v-model</code> 语法变更（默认使用 <code v-pre>modelValue</code> 替代 <code v-pre>value</code>）。</li>\n<li>事件总线 (<span v-pre class=\"katex\"><span class=\"katex-mathml\"><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>o</mi><mi>n</mi><mi mathvariant=\"normal\">/</mi></mrow><annotation encoding=\"application/x-tex\">on/</annotation></semantics></math></span><span class=\"katex-html\" aria-hidden=\"true\"><span class=\"base\"><span class=\"strut\" style=\"height:1em;vertical-align:-0.25em;\"></span><span class=\"mord mathnormal\">o</span><span class=\"mord mathnormal\">n</span><span class=\"mord\">/</span></span></span></span>off) 被移除，推荐使用第三方库（如 <code v-pre>mitt</code>）。</li>\n</ul>\n<h3 id=\"_6-类型支持\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#_6-类型支持\"><span>6. 类型支持</span></a></h3>\n<ul>\n<li><strong>Vue 2</strong>：对 TypeScript 的支持相对较弱，使用时需要额外的配置和声明文件。</li>\n<li><strong>Vue 3</strong>：从设计上就对 TypeScript 有更好的支持，组合式 API 能更自然地与 TypeScript 集成，代码类型更清晰。</li>\n</ul>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"::: tip 问题\nvue2 与 vue3 有哪些区别？\n:::\n\n---\n\n### 1. 响应式系统\n- **Vue 2**：基于 `Object.defineProperty()` 实现，通过劫持对象属性的 `getter` 和 `setter` 追踪变化。存在局限性，无法检测对象属性的添加或删除，对数组部分操作（如通过索引修改元素、修改数组长度）不能触发响应式更新。\n- **Vue 3**：采用 `Proxy` 对象实现，能拦截对象多种操作，可全面追踪数据变化，解决了 Vue 2 响应式系统的局限，对对象属性的添加、删除及数组操作都能很好地进行响应式处理。\n\n### 2. 组合式 API 与选项式 API\n- **Vue 2**：使用选项式 API，通过 `data`、`methods`、`computed`、`watch` 等选项组织代码。组件逻辑复杂时，同一功能代码分散，降低了代码可读性和可维护性。\n- **Vue 3**：引入组合式 API，有 `setup` 函数及一系列组合式函数，允许按逻辑功能组织代码，将相关代码放一起，提高了代码复用性和可维护性。\n\n### 3. 生命周期钩子\n- **Vue 2**：有 `beforeCreate`、`created`、`beforeMount`、`mounted`、`beforeUpdate`、`updated`、`beforeDestroy`、`destroyed` 等钩子函数。\n- **Vue 3**：部分钩子名称改变，如 `beforeDestroy` 变为 `onBeforeUnmount`，`destroyed` 变为 `onUnmounted`；还可在 `setup` 中使用组合式 API 形式的生命周期钩子。\n\n### 4. 性能优化\n- **Vue 2**：虚拟 DOM 采用传统的 Diff 算法，在处理大规模数据更新时性能会受到一定影响。\n- **Vue 3**：采用了静态提升、Patch Flag 等优化技术。静态提升可减少重复创建静态节点，Patch Flag 能精准标记动态节点，提高 Diff 算法效率，提升渲染性能。\n\n### 5. 破坏性变更\n\n- `v-model` 语法变更（默认使用 `modelValue` 替代 `value`）。\n- 事件总线 ($on/$off) 被移除，推荐使用第三方库（如 `mitt`）。\n\n### 6. 类型支持\n- **Vue 2**：对 TypeScript 的支持相对较弱，使用时需要额外的配置和声明文件。\n- **Vue 3**：从设计上就对 TypeScript 有更好的支持，组合式 API 能更自然地与 TypeScript 集成，代码类型更清晰。","excerpt":"","includedFiles":[],"tasklists":0,"title":"","headers":[{"level":3,"title":"1. 响应式系统","slug":"_1-响应式系统","link":"#_1-响应式系统","children":[]},{"level":3,"title":"2. 组合式 API 与选项式 API","slug":"_2-组合式-api-与选项式-api","link":"#_2-组合式-api-与选项式-api","children":[]},{"level":3,"title":"3. 生命周期钩子","slug":"_3-生命周期钩子","link":"#_3-生命周期钩子","children":[]},{"level":3,"title":"4. 性能优化","slug":"_4-性能优化","link":"#_4-性能优化","children":[]},{"level":3,"title":"5. 破坏性变更","slug":"_5-破坏性变更","link":"#_5-破坏性变更","children":[]},{"level":3,"title":"6. 类型支持","slug":"_6-类型支持","link":"#_6-类型支持","children":[]}]}}
