{"content":"<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">问题</p>\n<p>什么是闭包？<br>\n闭包有什么用途？</p>\n</div>\n<hr>\n<p><strong>闭包是指一个函数能够记住并访问它的词法作用域，即使这个函数在其词法作用域之外被调用。</strong></p>\n<h3 id=\"什么是闭包\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#什么是闭包\"><span>什么是闭包？</span></a></h3>\n<p>闭包是 <code v-pre>JavaScript</code> 中的一个重要概念，它发生在当一个函数嵌套在另一个函数内部时，内部函数可以访问外部函数的变量和参数，即使外部函数已经执行完毕并返回。</p>\n<p>简单来说，闭包就是“函数 + 函数声明时的词法作用域”组合形成的一个整体。</p>\n<hr>\n<h3 id=\"闭包的特性\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#闭包的特性\"><span>闭包的特性</span></a></h3>\n<ul>\n<li>内部函数可以访问外部函数的变量。</li>\n<li>外部函数执行完成后，其作用域不会立即销毁，而是被闭包保留。</li>\n<li>闭包可以让变量的生命周期延长，直到不再有任何引用为止。</li>\n</ul>\n<hr>\n<h3 id=\"闭包的作用\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#闭包的作用\"><span>闭包的作用</span></a></h3>\n<ul>\n<li><strong>数据封装与信息隐藏</strong>：通过闭包可以创建私有变量，避免全局污染。</li>\n<li><strong>回调函数和事件处理</strong>：在异步编程中，闭包常用于保存状态。</li>\n<li><strong>工厂函数</strong>：通过闭包返回特定功能的对象。</li>\n</ul>\n<h3 id=\"示例代码\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#示例代码\"><span>示例代码</span></a></h3>\n<div class=\"language-javascript line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"javascript\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code><span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">function</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> outerFunction</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">()</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">    let</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> outerVariable</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> \"</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">I'm outside!</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">\"</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">    function</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> innerFunction</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">()</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">        console</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">log</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">outerVariable</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">);</span><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\"> // 访问外部函数的变量</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">    return</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> innerFunction</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">;</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">const</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> closure</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> outerFunction</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">();</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">closure</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">();</span><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\"> // 输出: I'm outside!</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在这个例子中，<code v-pre>innerFunction</code> 是一个闭包，它记住了 <code v-pre>outerFunction</code> 的作用域，并能够在 <code v-pre>outerFunction</code> 执行完毕后继续访问 <code v-pre>outerVariable</code>。</p>\n<hr>\n<h3 id=\"闭包的注意事项\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#闭包的注意事项\"><span>闭包的注意事项</span></a></h3>\n<ul>\n<li><strong>内存泄漏</strong>：由于闭包会持有对外部作用域的引用，如果未正确释放，可能导致内存占用过高。</li>\n<li><strong>性能问题</strong>：过多使用闭包可能会影响程序性能，尤其是在循环或大量嵌套的情况下。</li>\n</ul>\n","env":{"base":"/","filePath":"D:/zhy-git/hoey-blog-plume/docs/notes/interview/3.JavaScript/5.闭包.md","filePathRelative":"notes/interview/3.JavaScript/5.闭包.md","frontmatter":{"title":"闭包","createTime":"2025/02/14 21:50:02","permalink":"/interview/20d108zg/"},"sfcBlocks":{"template":{"type":"template","content":"<template><div class=\"hint-container tip\">\n<p class=\"hint-container-title\">问题</p>\n<p>什么是闭包？<br>\n闭包有什么用途？</p>\n</div>\n<hr>\n<p><strong>闭包是指一个函数能够记住并访问它的词法作用域，即使这个函数在其词法作用域之外被调用。</strong></p>\n<h3 id=\"什么是闭包\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#什么是闭包\"><span>什么是闭包？</span></a></h3>\n<p>闭包是 <code v-pre>JavaScript</code> 中的一个重要概念，它发生在当一个函数嵌套在另一个函数内部时，内部函数可以访问外部函数的变量和参数，即使外部函数已经执行完毕并返回。</p>\n<p>简单来说，闭包就是“函数 + 函数声明时的词法作用域”组合形成的一个整体。</p>\n<hr>\n<h3 id=\"闭包的特性\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#闭包的特性\"><span>闭包的特性</span></a></h3>\n<ul>\n<li>内部函数可以访问外部函数的变量。</li>\n<li>外部函数执行完成后，其作用域不会立即销毁，而是被闭包保留。</li>\n<li>闭包可以让变量的生命周期延长，直到不再有任何引用为止。</li>\n</ul>\n<hr>\n<h3 id=\"闭包的作用\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#闭包的作用\"><span>闭包的作用</span></a></h3>\n<ul>\n<li><strong>数据封装与信息隐藏</strong>：通过闭包可以创建私有变量，避免全局污染。</li>\n<li><strong>回调函数和事件处理</strong>：在异步编程中，闭包常用于保存状态。</li>\n<li><strong>工厂函数</strong>：通过闭包返回特定功能的对象。</li>\n</ul>\n<h3 id=\"示例代码\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#示例代码\"><span>示例代码</span></a></h3>\n<div class=\"language-javascript line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"javascript\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code><span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">function</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> outerFunction</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">()</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">    let</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> outerVariable</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> \"</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">I'm outside!</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">\"</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">    function</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> innerFunction</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">()</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">        console</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">log</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">outerVariable</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">);</span><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\"> // 访问外部函数的变量</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">    return</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> innerFunction</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">;</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">const</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> closure</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> outerFunction</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">();</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">closure</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">();</span><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\"> // 输出: I'm outside!</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在这个例子中，<code v-pre>innerFunction</code> 是一个闭包，它记住了 <code v-pre>outerFunction</code> 的作用域，并能够在 <code v-pre>outerFunction</code> 执行完毕后继续访问 <code v-pre>outerVariable</code>。</p>\n<hr>\n<h3 id=\"闭包的注意事项\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#闭包的注意事项\"><span>闭包的注意事项</span></a></h3>\n<ul>\n<li><strong>内存泄漏</strong>：由于闭包会持有对外部作用域的引用，如果未正确释放，可能导致内存占用过高。</li>\n<li><strong>性能问题</strong>：过多使用闭包可能会影响程序性能，尤其是在循环或大量嵌套的情况下。</li>\n</ul>\n</template>","contentStripped":"<div class=\"hint-container tip\">\n<p class=\"hint-container-title\">问题</p>\n<p>什么是闭包？<br>\n闭包有什么用途？</p>\n</div>\n<hr>\n<p><strong>闭包是指一个函数能够记住并访问它的词法作用域，即使这个函数在其词法作用域之外被调用。</strong></p>\n<h3 id=\"什么是闭包\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#什么是闭包\"><span>什么是闭包？</span></a></h3>\n<p>闭包是 <code v-pre>JavaScript</code> 中的一个重要概念，它发生在当一个函数嵌套在另一个函数内部时，内部函数可以访问外部函数的变量和参数，即使外部函数已经执行完毕并返回。</p>\n<p>简单来说，闭包就是“函数 + 函数声明时的词法作用域”组合形成的一个整体。</p>\n<hr>\n<h3 id=\"闭包的特性\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#闭包的特性\"><span>闭包的特性</span></a></h3>\n<ul>\n<li>内部函数可以访问外部函数的变量。</li>\n<li>外部函数执行完成后，其作用域不会立即销毁，而是被闭包保留。</li>\n<li>闭包可以让变量的生命周期延长，直到不再有任何引用为止。</li>\n</ul>\n<hr>\n<h3 id=\"闭包的作用\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#闭包的作用\"><span>闭包的作用</span></a></h3>\n<ul>\n<li><strong>数据封装与信息隐藏</strong>：通过闭包可以创建私有变量，避免全局污染。</li>\n<li><strong>回调函数和事件处理</strong>：在异步编程中，闭包常用于保存状态。</li>\n<li><strong>工厂函数</strong>：通过闭包返回特定功能的对象。</li>\n</ul>\n<h3 id=\"示例代码\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#示例代码\"><span>示例代码</span></a></h3>\n<div class=\"language-javascript line-numbers-mode\" data-highlighter=\"shiki\" data-ext=\"javascript\" style=\"--shiki-light:#393a34;--shiki-dark:#dbd7caee;--shiki-light-bg:#ffffff;--shiki-dark-bg:#121212\"><pre class=\"shiki shiki-themes vitesse-light vitesse-dark vp-code\" v-pre=\"\"><code><span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">function</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> outerFunction</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">()</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">    let</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> outerVariable</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\"> \"</span><span style=\"--shiki-light:#B56959;--shiki-dark:#C98A7D\">I'm outside!</span><span style=\"--shiki-light:#B5695977;--shiki-dark:#C98A7D77\">\"</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">;</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">    function</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> innerFunction</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">()</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> {</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">        console</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">.</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">log</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">(</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\">outerVariable</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">);</span><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\"> // 访问外部函数的变量</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">    }</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#1E754F;--shiki-dark:#4D9375\">    return</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> innerFunction</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">;</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">}</span></span>\n<span class=\"line\"></span>\n<span class=\"line\"><span style=\"--shiki-light:#AB5959;--shiki-dark:#CB7676\">const</span><span style=\"--shiki-light:#B07D48;--shiki-dark:#BD976A\"> closure</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\"> =</span><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\"> outerFunction</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">();</span></span>\n<span class=\"line\"><span style=\"--shiki-light:#59873A;--shiki-dark:#80A665\">closure</span><span style=\"--shiki-light:#999999;--shiki-dark:#666666\">();</span><span style=\"--shiki-light:#A0ADA0;--shiki-dark:#758575DD\"> // 输出: I'm outside!</span></span></code></pre>\n<div class=\"line-numbers\" aria-hidden=\"true\" style=\"counter-reset:line-number 0\"><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div><div class=\"line-number\"></div></div></div><p>在这个例子中，<code v-pre>innerFunction</code> 是一个闭包，它记住了 <code v-pre>outerFunction</code> 的作用域，并能够在 <code v-pre>outerFunction</code> 执行完毕后继续访问 <code v-pre>outerVariable</code>。</p>\n<hr>\n<h3 id=\"闭包的注意事项\" tabindex=\"-1\"><a class=\"header-anchor\" href=\"#闭包的注意事项\"><span>闭包的注意事项</span></a></h3>\n<ul>\n<li><strong>内存泄漏</strong>：由于闭包会持有对外部作用域的引用，如果未正确释放，可能导致内存占用过高。</li>\n<li><strong>性能问题</strong>：过多使用闭包可能会影响程序性能，尤其是在循环或大量嵌套的情况下。</li>\n</ul>\n","tagOpen":"<template>","tagClose":"</template>"},"script":null,"scriptSetup":null,"scripts":[],"styles":[],"customBlocks":[]},"content":"::: tip 问题\r\n什么是闭包？  \r\n闭包有什么用途？\r\n:::\r\n\r\n---\r\n\r\n**闭包是指一个函数能够记住并访问它的词法作用域，即使这个函数在其词法作用域之外被调用。**\r\n\r\n### 什么是闭包？\r\n闭包是 `JavaScript` 中的一个重要概念，它发生在当一个函数嵌套在另一个函数内部时，内部函数可以访问外部函数的变量和参数，即使外部函数已经执行完毕并返回。\r\n\r\n简单来说，闭包就是“函数 + 函数声明时的词法作用域”组合形成的一个整体。\r\n\r\n---\r\n\r\n### 闭包的特性\r\n- 内部函数可以访问外部函数的变量。\r\n- 外部函数执行完成后，其作用域不会立即销毁，而是被闭包保留。\r\n- 闭包可以让变量的生命周期延长，直到不再有任何引用为止。\r\n\r\n---\r\n\r\n### 闭包的作用\r\n- **数据封装与信息隐藏**：通过闭包可以创建私有变量，避免全局污染。\r\n- **回调函数和事件处理**：在异步编程中，闭包常用于保存状态。\r\n- **工厂函数**：通过闭包返回特定功能的对象。\r\n\r\n### 示例代码\r\n```javascript\r\nfunction outerFunction() {\r\n    let outerVariable = \"I'm outside!\";\r\n\r\n    function innerFunction() {\r\n        console.log(outerVariable); // 访问外部函数的变量\r\n    }\r\n\r\n    return innerFunction;\r\n}\r\n\r\nconst closure = outerFunction();\r\nclosure(); // 输出: I'm outside!\r\n```\r\n\r\n在这个例子中，`innerFunction` 是一个闭包，它记住了 `outerFunction` 的作用域，并能够在 `outerFunction` 执行完毕后继续访问 `outerVariable`。\r\n\r\n---\r\n\r\n### 闭包的注意事项\r\n- **内存泄漏**：由于闭包会持有对外部作用域的引用，如果未正确释放，可能导致内存占用过高。\r\n- **性能问题**：过多使用闭包可能会影响程序性能，尤其是在循环或大量嵌套的情况下。","excerpt":"","includedFiles":[],"tasklistId":0,"title":"","headers":[{"level":3,"title":"什么是闭包？","slug":"什么是闭包","link":"#什么是闭包","children":[]},{"level":3,"title":"闭包的特性","slug":"闭包的特性","link":"#闭包的特性","children":[]},{"level":3,"title":"闭包的作用","slug":"闭包的作用","link":"#闭包的作用","children":[]},{"level":3,"title":"示例代码","slug":"示例代码","link":"#示例代码","children":[]},{"level":3,"title":"闭包的注意事项","slug":"闭包的注意事项","link":"#闭包的注意事项","children":[]}]}}
