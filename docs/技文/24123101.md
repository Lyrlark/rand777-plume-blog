---
title: Vue3+Ts 手搓一个好看的文件树
createTime: 2024/12/31
tags:
 - Vue
 - TypeScript
permalink: /article/24123101/
---


使用 `Vue3` 做一个能够通过选定的本地文件夹生成一个类似 `IDE` 左侧的文件树，同时点击文件可显示基本信息的功能。  
<!-- more -->  

以下是对其过程的详细讲解，若只需要了解代码，。

## 1. 效果展示

![24123101_01.png](/assets/24123101_01.png)

## 1. 实现过程
要实现文件树最大的核心在于 **解析文件夹结构** 与 **构建文件树** 。

### 1.1 定义文件树节点
文件树与数据结构中的树类似，将每个文件抽象为一个节点，节点包含 **文件名、路径、子文件、折叠状态**。
```ts
interface FileItem {
  name: string;
  path: string;
  children?: FileItem[];
  collapsed?: boolean;
}
```
### 1.2 构建文件树
将一个 `FileList` 对象转换成一个树形结构的 `FileItem` 数组。
每个 `FileItem` 代表一个文件或文件夹，并包含其子文件或子文件夹。
```ts
const buildFileTree = (files: FileList): FileItem[] => {
  // 初始化根节点 其名称为 root，路径为空，子节点为空数组。
  const root: FileItem = {name: 'Root', path: '', children: []};
  for (let i = 0; i < files.length; i++) {  //遍历选中的文件夹
    const file = files[i];  // i = 0 为第一个子文件
    // 使用 webkitRelativePath 获取文件的相对路径，并将其按 / 分割成数组 pathParts。
    // 当i=0 ，pathParts为第一个字文件夹的相对路径
    const pathParts = file.webkitRelativePath.split('/');
    // currentLevel 初始化为节点的子节点数组。
    let currentLevel = root.children!;
    for (let j = 0; j < pathParts.length; j++) {
      const part = pathParts[j];
      const existingPath = currentLevel.find((item) => item.name === part);
      if (existingPath) {
        currentLevel = existingPath.children || [];
      } else {
        const newItem: FileItem = {name: part, path: file.webkitRelativePath};
        if (j < pathParts.length - 1) {
          newItem.children = [];
        }
        currentLevel.push(newItem);
        currentLevel = newItem.children || [];
      }
    }
  }
  return root.children || [];
};
```

